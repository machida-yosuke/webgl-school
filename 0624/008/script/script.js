
// = 008 ======================================================================
// このサンプルは、JavaScript のコードは 007 のときと全く同じです。
// コメントが付いている場所が変わっているだけで、処理内容は自体は同じです。
// WebGL に限らず、3D プログラミングでは絶対に行列を避けて通ることはできません。
// しかし、行列の処理の中身についてまで厳密に理解している必要はありません。まず
// 最初は、それぞれの行列の名前、そしてその効果や意味をしっかり理解しましょう。
// ============================================================================

(() => {
    // variables
    let run;        // 実行フラグ
    let startTime;  // ループ開始時間
    let nowTime;    // 現在までの経過時間
    let gl;         // WebGL Rendering Context
    let mat4;       // glcubic.Math.Mat4 クラス
    let canvas;     // canvas エレメントへの参照
    let canvasSize; // canvas の大きさ（ここでは正方形の一辺の長さ）
    let prg;        // プログラムオブジェクト
    let position;   // 頂点の位置座標
    let color;      // 頂点の色
    let index;      // 頂点インデックス
    let VBO;        // Vertex Buffer Object
    let IBO;        // Index Buffer Object

    let mMatrix;    // モデル座標変換行列
    let vMatrix;    // ビュー座標変換行列
    let pMatrix;    // プロジェクション座標変換行列
    let vpMatrix;   // ビュー x プロジェクション
    let mvpMatrix;  // モデル x ビュー x プロジェクション

    window.addEventListener('load', () => {
        // glcubic の初期化
        canvas = document.getElementById('webgl_canvas');
        gl3.init(canvas);
        if(!gl3.ready){
            console.log('initialize error');
            return;
        }
        // 記述が冗長になるので WebGL のコンテキストを取得しておく
        gl = gl3.gl;
        // こちらも同様に、記述が冗長になるので変数にいったん格納
        mat4 = gl3.Math.Mat4;

        // サンプルの実行を止めることができるようにイベントを仕込む
        window.addEventListener('keydown', (eve) => {
            // Esc キーを押下したら run に false が入るようにする
            run = eve.key !== 'Escape';
        }, false);

        // キャンバスの大きさはウィンドウの短辺
        canvasSize = Math.min(window.innerWidth, window.innerHeight);
        canvas.width  = canvasSize;
        canvas.height = canvasSize;

        // シェーダロードへ移行
        loadShader();
    }, false);

    function loadShader(){
        // glcubic の機能を使ってプログラムを生成
        prg = gl3.createProgramFromFile(
            './shader/main.vert',
            './shader/main.frag',
            ['position', 'color'],
            [3, 4],
            ['mvpMatrix', 'globalColor'],
            ['matrix4fv', '4fv'],
            initialize
        );
    }

    function initialize(){
        // 頂点の座標データ
        position = [
            -0.5,  0.5,  0.5, // ひとつ目の三角形の第一頂点
             0.5,  0.0,  0.5, // ひとつ目の三角形の第二頂点
            -0.5, -0.5,  0.5, // ひとつ目の三角形の第三頂点
             0.5,  0.5, -0.5, // ふたつ目の三角形の第一頂点
            -0.5,  0.0, -0.5, // ふたつ目の三角形の第二頂点
             0.5, -0.5, -0.5  // ふたつ目の三角形の第三頂点
        ];
        // 頂点の色データ
        color = [
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0, // ひとつ目の三角形は赤に
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0  // ふたつ目の三角形は緑に
        ];
        // インデックスデータ
        index = [
            0, 2, 1, // ひとつ目の三角形に使うインデックス
            3, 5, 4  // ふたつ目の三角形に使うインデックス
        ];
        // 座標データから頂点バッファを生成
        VBO = [
            gl3.createVbo(position),
            gl3.createVbo(color)
        ];
        // インデックスバッファを生成
        IBO = gl3.createIbo(index);

        // - 行列の種類 -------------------------------------------------------
        // 3D プログラミングで誰もが最初に戸惑う存在……それが行列です。
        // WebGL には、API として行列処理をサポートする機能はありません。つまり、
        // JavaScript の行列処理は、自分でなんとかするしかありません。
        // このスクールでは、glcubic.js に行列処理用の一連のヘルパー系メソッドが
        // ありますので、それを使って進めていきます。
        // 以下は、行列処理を行うための変数宣言ですが、行列の中身は実態としては
        // 単なる長さ 16 の配列です。
        // --------------------------------------------------------------------
        // . mMatrix - モデル座標変換行列 .....................................
        // モデル座標変換は、別名「ワールド座標変換」とも呼ばれます。
        // この座標変換は、頂点を三次元空間内で移動させたり、回転させたりする効
        // 果があります。
        // ....................................................................
        // . vMatrix - ビュー座標変換行列 .....................................
        // ビュー座標変換は、その名の示すとおりビュー、つまりカメラに映るものに
        // ついての影響を頂点に与える効果があります。より具体的に言うと、カメラ
        // がどこにあるのか、あるいはどこを向いているのかなどを考慮して、頂点に
        // 適切に処理を加えてくれる変換です。
        // ....................................................................
        // . pMatrix - プロジェクション座標変換行列 ...........................
        // プロジェクション座標変換は、いわゆるプロジェクターのように「投影」に
        // 関する変換を行う座標変換です。もう少しわかりやすく言うと、三次元空間
        // のどこからどこまでの範囲を、スクリーンに出すか（投影するか）を決める
        // 役割を持ちます。
        // ....................................................................
        // 行列変数の宣言
        mMatrix   = mat4.identity(mat4.create()); // モデル座標変換行列
        vMatrix   = mat4.identity(mat4.create()); // ビュー座標変換行列
        pMatrix   = mat4.identity(mat4.create()); // プロジェクション座標変換行列
        vpMatrix  = mat4.identity(mat4.create()); // v と p を掛け合わせたもの
        mvpMatrix = mat4.identity(mat4.create()); // m と v と p の全てを掛け合わせたもの

        // - ビュー座標変換行列 -----------------------------------------------
        // glcubic.js では、Mat4.lookAt メソッドでビュー座標変換行列を生成するこ
        // とができます。
        // 第一引数：カメラの座標
        // 第二引数：カメラの注視点（見つめる座標）
        // 第三引数：カメラの上方向（天井が向いている方向）
        // 戻り値で結果を受けるか、第四引数に与えると行列が更新されます。
        // --------------------------------------------------------------------
        mat4.lookAt([0.0, 0.0, 3.0], [0.0, 0.0, 0.0], [0.0, 1.0, 0.0], vMatrix);
        // - プロジェクション座標変換行列 -------------------------------------
        // glcubic.js では、Mat4.perspective メソッドでプロジェクション座標変換
        // 行列を生成することができます。
        // 第一引数：カメラの視野角（Field of View）
        // 第二引数：視錐台の縦横比（幅 / 高さ）
        // 第三引数：ニアクリップ面（視錐台のカメラに近い面）
        // 第四引数：ファークリップ面（視錐台のカメラから遠い面）
        // 戻り値で結果を受けるか、第五引数に与えると行列が更新されます。
        // --------------------------------------------------------------------
        mat4.perspective(45, 1.0, 0.1, 6.0, pMatrix);
        // - 行列を掛け合わせる -----------------------------------------------
        // 行列同士を掛け合わせるには Mat4.multiply メソッドを使います。
        // 行列と行列は、ある一定の条件を満たしている場合は掛け算を行うことがで
        // きるのですが、それを行ってくれるメソッドが multiply です。
        // 引数の与える順番が、行列の計算の仕方の都合上、直感と逆になる（行列を
        // ちゃんと勉強するとその謎は解けるのですが、今は気にしなくても大丈夫）
        // ので気をつけましょう。
        // 戻り値で結果を受けるか、第三引数に与えると行列が更新されます。
        // --------------------------------------------------------------------
        mat4.multiply(pMatrix, vMatrix, vpMatrix);

        // 深度テストとカリングを有効化する
        gl.enable(gl.DEPTH_TEST); // 深度テストを有効化
        gl.enable(gl.CULL_FACE);  // カリングを有効化
        gl.cullFace(gl.BACK);     // カリング面の設定

        // 汎用変数の初期化
        run = true;
        startTime = Date.now();
        nowTime = 0;

        // レンダリング関数を呼ぶ
        render();
    }

    function render(){
        // ビューを設定
        gl3.sceneView(0, 0, canvasSize, canvasSize);
        // シーンのクリア
        gl3.sceneClear([0.7, 0.7, 0.7, 1.0]);
        // どのプログラムオブジェクトを利用するか明示的に設定
        prg.useProgram();
        // プログラムに頂点バッファとインデックスバッファをアタッチ
        prg.setAttribute(VBO, IBO);

        // - モデル座標変換行列 -----------------------------------------------
        // このサンプルではカメラは動かないので vp の両行列についてはループ中に
        // 更新する必要はありませんが、頂点は動き続けるので、ループ内で毎回更新
        // します。
        // --------------------------------------------------------------------
        // 時間の経過を得る（Date.now は現在時刻のタイムスタンプをミリ秒で返す）
        nowTime = (Date.now() - startTime) / 1000;
        mat4.identity(mMatrix);
        // . モデル座標変換で回転を加える .....................................
        // 頂点に回転を加えるモデル座標変換は、Mat4.rotate で行えます。
        // 第一引数：処理のベースとなる行列変数
        // 第二引数：回転する量（ラジアン単位）
        // 第三引数：回転する際の軸を表すベクトル
        // 戻り値で結果を受けるか、第四引数に与えると行列が更新されます。
        // ....................................................................
        mat4.rotate(mMatrix, nowTime, [0.0, 1.0, 0.0], mMatrix);
        mat4.multiply(vpMatrix, mMatrix, mvpMatrix);
        // uniform 変数をシェーダにプッシュ
        prg.pushShader([
            mvpMatrix,
            [1.0, 1.0, 1.0, 1.0]
        ]);
        // ドローコール（描画命令）
        gl3.drawElements(gl3.gl.TRIANGLES, index.length);

        // 再帰呼び出し
        if(run){requestAnimationFrame(render);}
    }
})();

