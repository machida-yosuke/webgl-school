
// = 001 ======================================================================
// ほぼ最小構成の WebGL 実装サンプルです。
// Canvas Element を正しく参照できるようにするため onload をトリガーとして処理が
// 動き出すようにします。また、実装には glcubic.js を使っていますが、これは冗長
// な WebGL に関する処理をまとめたヘルパー関数の集合体だと思ってください。
// 実際のスクールの講義のなかでは、このヘルパー関数群の中身についても、口頭で説
// 明を加えながら言及する場合があります。
// ここでは最初なので、コメント多めでいきます。
// ============================================================================

(() => {
    // variables
    let canvas;     // canvas エレメントへの参照
    let canvasSize; // canvas の大きさ（ここでは正方形の一辺の長さ）
    let prg;        // プログラムオブジェクト
    let position;   // 頂点の位置座標
    let VBO;        // Vertex Buffer Object

    window.addEventListener('load', () => {
        // - WebGL コンテキストを初期化する -----------------------------------
        // HTML5 の Canvas Element には「コンテキスト」を生成する機能があります。
        // getContext メソッドにどのような文字列を与えたのかによって、生成される
        // コンテキストの種類が変化します。
        // '2d' という文字列を与えると Canvas2D コンテキストが取得できます。ここ
        // に 'webgl' という文字列を与えると、WebGLRenderingContext が取得できま
        // す。これが WebGL を扱うためのコンテキストで多数のプロパティやメソッド
        // を持つ、いわば WebGL の実体です。
        // glcubic.js では、init メソッドに対象となる canvas エレメントに設定し
        // た id の文字列、もしくは canvas エレメントそのものへの参照を渡します。
        // ready プロパティが true になっているなら、コンテキストの初期化が正し
        // く完了したことを表しています。
        // --------------------------------------------------------------------
        // glcubic の初期化
        canvas = document.getElementById('webgl_canvas');
        gl3.init(canvas);
        // ready プロパティが false の場合初期化失敗
        if(!gl3.ready){
            console.log('initialize error');
            return;
        }

        // - キャンバスの初期サイズ -------------------------------------------
        // フロントエンドの実装を行っていると、画像をページ内に配置することがあ
        // るかと思います。このとき、画面上で画像がどのような大きさで描画されて
        // いるのかと、もともとの画像ファイルがどのような解像度になっているのか
        // は必ずしも一致しませんよね。
        // それと同じで、canvas エレメントの大きさと「WebGL の描画領域の大きさ」
        // は必ずしも一致しません。これは非常に重要な事実です。
        // ですが、まず WebGL に不慣れなうちは特に、両者の大きさは一致させるよう
        // にしたほうがいいでしょう。以下のように canvas の大きさをウィンドウサ
        // イズにぴったり揃えてしまい、これを基準として考えられるようにしておき
        // ましょう。
        // --------------------------------------------------------------------
        // キャンバスの大きさはウィンドウの短辺
        canvasSize = Math.min(window.innerWidth, window.innerHeight);
        canvas.width  = canvasSize;
        canvas.height = canvasSize;

        // シェーダロードへ移行
        loadShader();
    }, false);

    function loadShader(){
        // - プログラムオブジェクト -------------------------------------------
        // WebGL に欠かせない概念に「シェーダ」があります。
        // シェーダは GPU 上で高速に動作する特殊なプログラムの総称ですが、どのよ
        // うなプラットフォームを使っているのかによって、扱い方は様々です。
        // WebGL の場合は OpenGL 系なので「GLSL」と呼ばれる専用のシェーダ記述言
        // 語を用いてシェーダプログラムを記述します。
        // そして JavaScript のアプリケーション側からこのシェーダにアクセスする
        // ために必要になるのが、プログラムオブジェクトです。名前が紛らわしいで
        // すが、要はシェーダを「それ単体で動作するひとつのプログラム」としてみ
        // なす、として考えるといいのではないでしょうか。
        // 原則、ひとつのシェーダの組に対して、ひとつのプログラムオブジェクトが
        // 必要になります。
        // --------------------------------------------------------------------
        // glcubic の機能を使ってプログラムを生成
        prg = gl3.createProgramFromFile(
            './shader/main.vert',
            './shader/main.frag',
            ['position'],
            [3],
            [],
            [],
            initialize // コールバックに初期化処理を渡しておく
        );
    }

    function initialize(){
        // - 頂点データ（ジオメトリ） -----------------------------------------
        // three.js にはジオメトリという概念があり、しかも組み込みで最初から複数
        // のジオメトリが用意されていました。
        // ただ残念ながら、WebGL にはそもそも組み込みのジオメトリなんてものは存
        // 在しません。全部自分で頂点を定義して、組み上げていってやらなくてはな
        // らないのです。（怖いですね！）
        // ここでは、単純な三角形のポリゴンを一枚だけ、定義しています。
        // --------------------------------------------------------------------
        // 頂点の座標データ
        position = [
             0.0,  0.5,  0.0, // ひとつ目の頂点の x, y, z 座標
             0.5, -0.5,  0.0, // ふたつ目の頂点の x, y, z 座標
            -0.5, -0.5,  0.0  // みっつ目の頂点の x, y, z 座標
        ];

        // . Vertex Buffer Object .............................................
        // WebGL は、非常に高速に動作します。これは、シェーダが GPU 上で超高速に
        // 動作してくれるからなのですが……
        // そもそも、CPU 上で動作する JavaScript からどうやって GPU に頂点の情報
        // を渡すのでしょうか。
        // その解答のひとつの答えが、ここで出てくる VBO です。VBO は GPU 上のメ
        // モリ領域に作られるオブジェクトで、WebGL ではこの VBO という概念に座標
        // などの頂点データを流し込むことで、GPU が参照しやすい領域に頂点の情報
        // を置いておくことができるようになっているのですね。
        // ....................................................................
        // 座標データから頂点バッファを生成
        VBO = [
            gl3.createVbo(position)
        ];

        // レンダリング関数を呼ぶ
        render();
    }

    // - レンダリング -----------------------------------------------------
    // ここまでの手順は全て、画面に WebGL でレンダリングを行うための事前準備
    // に過ぎませんでした。以下の render 関数は、いよいよそれらの準備した情
    // 報をもとに、画面にレンダリングを行う部分です。
    // --------------------------------------------------------------------
    function render(){
        // . ビューポートの設定とクリア ...................................
        // 先ほども書いたように、WebGL の描画領域は Canvas Element のエレメ
        // ントとしての領域とは別に、内部的に用意されています。一般にこの描
        // 画の対象となる領域のことを「ビューポート」または単にビューと呼び
        // ます。
        // ビューポートの大きさはいつでも任意に変更できますが、特に理由がな
        // い限りは Canvas Element と同じ大きさにするべきです。そうすること
        // で、ドットバイドットで、正しい解像度で描画が行われます。
        // また、このビューポートは明示的にリセットされるべきとされています
        // ので特定の色で描画を行う前にリセットします。
        // ................................................................
        // ビューを設定
        gl3.sceneView(0, 0, canvasSize, canvasSize);
        // シーンのクリア
        gl3.sceneClear([0.7, 0.7, 0.7, 1.0]);

        // . 利用するプログラム（シェーダ）を指定 .........................
        // これも先に書きましたが、シェーダとは GPU 上で動作する一種のプログ
        // ラムですので、実際になにかしらの描画を行う前に、まずはどのシェー
        // ダを使うのかを明示的に示してやる必要があります。
        // また、利用する頂点（描くべき頂点）がどれであるかを明確にするため、
        // プログラムオブジェクトに対して VBO を紐付けてやります。
        // こうすることで「セットしたシェーダ」で「セットした頂点」が描かれ
        // るようになるわけですね。
        // ................................................................
        // どのプログラムオブジェクトを利用するか明示的に設定
        prg.useProgram();
        // プログラムに頂点バッファをアタッチ
        prg.setAttribute(VBO);

        // . ドローコール .................................................
        // ここまでに見てきた全ての手順が済むと、既に GPU 上には描くべき頂点
        // の情報や、それを描くシェーダの情報が全て揃ったことになります。
        // これらの全ての準備が整ったら、やっと「絵を描け！」と命令すること
        // ができるようになります。
        // ドローコールとは、draw call であり、これが描画命令に相当します。
        // WebGL にはいくつかドローコールがあるのですが、ここでは理解を簡単
        // にするために、ひとまず glcubic.js のドローコールラッパーメソッド
        // で描画命令を発行してやりましょう。
        // ................................................................
        // ドローコール（描画命令）
        gl3.drawArrays(gl3.gl.TRIANGLES, position.length / 3);
    }
})();

